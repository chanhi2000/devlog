{
  "channel": {
    "id": "bluedawnstar",
    "name": "개발자영맨",
    "profile": "https://yt3.googleusercontent.com/ytc/APkrFKanEI0XhrN7f-IdbCL1hyhCgraCFfeVhcIc9bCyyA=s176-c-k-c0x00ffffff-no-rj",
    "banner": ""
  },
  "videos": [
    { "id": "RHGfn52cHHw", "title": "[String] String searching #1 -  prefix function & KMP (재녹음)" },
    { "id": "wZVwU8-yfg0", "title": "[개발 팁] 주석 토클링, 들어 봤나요?" },
    { "id": "egqYGMOm_48", "title": "[String] String searching #2 - Rabin-Karp algorithm" },
    { "id": "85iAoSBqfKQ", "title": "[Algorithm] dynamic programming #5 - 격자에서의 경로 - Part 1" },
    { "id": "nkXGo_PoOGU", "title": "[Algorithm] dynamic programming #5 - 격자에서의 경로 - Part 2" },
    { "id": "XohwMF1lgT4", "title": "[Algorithm] dynamic programming #5 - 격자에서의 경로 - 번외 문제(Part 3)" }
  ],
  "playlists": [
    {
      "title": "Data Structures & Algorithms",
      "videos": [
        { "id": "PFb-FSNQdoU", "title": "[잡담] 알고리즘, 어떻게 공부할 것인가?" },
        { "id": "bm9bxsO-2d0", "title": "[Algorithm] dynamic programming #4 - Knapsack Problem - Part 3" },
        { "id": "lyLeYz3LCRc", "title": "[Algorithm] dynamic programming #4 - Knapsack Problem - Part 2" },
        { "id": "tWTd5CpjVAE", "title": "[Algorithm] dynamic programming #4 - Knapsack Problem - Part 1" },
        { "id": "LmYUD-VgHQA", "title": "[Algorithm] dynamic programming #3 - Maximum Subarray Problem" },
        { "id": "QYN-waLZI5c", "title": "[Algorithm] dynamic programming #2 - Fibonacci 계열 문제" },
        { "id": "gt2pla0zDEA", "title": "[Algorithm] dynamic programming #1 - introduction" },
        { "id": "kmmTzc6RmC0", "title": "[Data Structure] union-find #2 - 예제" },
        { "id": "WUz7U2BjecQ", "title": "[Data Structure] union-find #1" },
        { "id": "49Rtqioh-y0", "title": "[Heap] 이진 힙(binary heap) #8 - 예제6" },
        { "id": "mGgZJPUohN0", "title": "[Heap] 이진 힙(binary heap) #7 - 예제5" },
        { "id": "V_e67iXH67U", "title": "[Heap] 이진 힙(binary heap) #6 - 예제3,4" },
        { "id": "b80yPavBkLw", "title": "[Heap] 이진 힙(binary heap) #5 - 예제2" },
        { "id": "ovEUvOygXIY", "title": "[Heap] 이진 힙(binary heap) #4 - 예제1" },
        { "id": "a4GeiTr_Mvc", "title": "[Heap] 이진 힙(binary heap) #3 - 어디에/어떻게 사용하는가?" },
        { "id": "1qa8U-w8_1k", "title": "[Heap] 이진 힙(binary heap) #2 - 힙 만들기(heapify)" },
        { "id": "y2h-tHJ1Jec", "title": "[Heap] 이진 힙(binary heap) #1 - push, pop" },
        { "id": "xNSRgwIk3UI", "title": "[Selection] quickselect algorithm" },
        { "id": "5EnOcJY04xE", "title": "[Sorting] quicksort #3 - 3-way partitioning" },
        { "id": "nmi7_SH2k48", "title": "[Sorting] quicksort #2 - Hoare partition, pivot selection" },
        { "id": "_K2RRWOYlbg", "title": "[Sorting] quicksort #1 - introduction + Lomuto partition scheme" },
        { "id": "N7EoObpzjkY", "title": "[Data Structure] merge sort tree #2 - 2D" },
        { "id": "wL8x7fK4-NA", "title": "[Data Structure] merge sort tree #1" },
        { "id": "Kzu7-1OYTTA", "title": "[Sorting] merge sort #3 -  bottom-up merge sort + improvement ideas" },
        { "id": "gqNzIvtxnfA", "title": "[Sorting] merge sort #2 -  top-down merge sort + examples" },
        { "id": "IUj7WEHYrZc", "title": "[Sorting] merge sort #1 -  merge operation" },
        { "id": "LKVOiLNk3JM", "title": "[Sorting] shellsort" },
        { "id": "p6DG1bmKdWI", "title": "[Sorting] swap, bubble/selection/insertion sort" },
        { "id": "EF_7bLB4O8I", "title": "[Sorting] introduction" },
        { "id": "q50mW6ZU2pI", "title": "[Algorithm] ternary search - #2 (feat. convex function)" },
        { "id": "60DmlS4SmjM", "title": "[Algorithm] ternary search - #1" },
        { "id": "P8b2KrB9ezk", "title": "[Algorithm] binary search  - #5 (example-4)" },
        { "id": "J4DJ9EwvC_w", "title": "[Algorithm] binary search  - #4 (example-3)" },
        { "id": "zxMZ9Vdu-K0", "title": "[Algorithm] binary search  - #3 (example-2)" },
        { "id": "A55yjmH5TQs", "title": "[Algorithm] binary search  - #2 (decision problem, example-1)" },
        { "id": "k5A3HicbLec", "title": "[Algorithm] binary search  - #1 (binary search, lower/upper bound)" },
        { "id": "dJpNh7R4LM8", "title": "[Range Query] Segment Tree - lazy propagation" },
        { "id": "DPNI3cf6eC0", "title": "[Range Query] Sqrt Tree" },
        { "id": "b_rsXu1pn08", "title": "[Range Query] 알고리즘/자료구조 정리" },
        { "id": "XyKRc71z9Pk", "title": "[Range Query] Disjoint Sparse Table" },
        { "id": "toBt6dHcvdA", "title": "[Range Query] Sparse Table" },
        { "id": "UV81ONajQIs", "title": "[Range Query] Square Root Decomposition" },
        { "id": "ahFB9eCnI6c", "title": "[Range Query] Segment Tree #2/2 - code" },
        { "id": "075fcq7oCC8", "title": "[Range Query] Segment Tree #1/2 - introduction" },
        { "id": "KT864Aa3zE0", "title": "[Range Sum] 2D 구간 합 #1 - 2D prefix sum" },
        { "id": "f9xL16rv9K8", "title": "[Sliding Window] #3/3 - LeetCode 76. Minimum Window Substring" },
        { "id": "xzRYqeoPyLk", "title": "[Sliding Window] #2/3 - LeetCode 3. Longest Substring Without Repeating Characters" },
        { "id": "0uSEKnn5hJg", "title": "[Sliding Window] #1/3 - \"Substrings of size K with K distinct chars\" (Amazon)" },
        { "id": "SkZA7752zS0", "title": "[String] string matching #3 - KMP and prefix function (2/2)" },
        { "id": "SkZA7752zS0", "title": "[String] string matching #3 - KMP and prefix function (2/2)" },
        { "id": "OhMFeV8VeAc", "title": "[String] string matching #2 - KMP and prefix function (1/2)" },
        { "id": "OhMFeV8VeAc", "title": "[String] string matching #2 - KMP and prefix function (1/2)" },
        { "id": "_hsHF9_C_GQ", "title": "[String] string matching #1- introduction" },
        { "id": "_hsHF9_C_GQ", "title": "[String] string matching #1- introduction" },
        { "id": "OTLqjdjpJzA", "title": "[Range Sum] 구간 합 #3 - Range Add & Range Sum" },
        { "id": "gtU9NvsDuh8", "title": "[Range Sum] 구간 합 #2 - Binary Indexed Tree (Fenwick Tree)" },
        { "id": "_2DOKWvGets", "title": "[Range Sum] 구간 합 #1 - 1차원 prefix sum" },
        { "id": "kaIZnfwYg1M", "title": "[Algorithm] 모든 조합(부분집합) 구하기 (2/2) - 중복이 있는 경우" },
        { "id": "wy678Yc5iqE", "title": "[Algorithm] 모든 조합(부분집합) 구하기 (1/2)" },
        { "id": "YiGxC9hAg4s", "title": "[Graph] Basic 7 - 모든 쌍의 최단 거리 찾기 Floyd Warshall" },
        { "id": "CL6J3X0YZdk", "title": "[Graph] Basic 6 - Dijkstra 3/3" },
        { "id": "GEYYC9TBqoQ", "title": "[Graph] Basic 5 - Dijkstra 2/3" },
        { "id": "2AMVXqD_iCA", "title": "[Graph] Basic 4 - Dijkstra 1/3" },
        { "id": "eNcmpisoIx4", "title": "[Graph] Basic 2 -  DFS를 이용한 cycle detection" },
        { "id": "w9oIzfRDToQ", "title": "[Graph] Basic 3 - weight 없는 graph에서 최단 거리 계산" },
        { "id": "nEDkeZvF4lg", "title": "[Graph] Basic 1 - graph 표현, DFS, BFS" }
      ]
    }
  ]
}